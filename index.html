<!DOCTYPE html>
<html lang="ko">
<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5975580696697245"
            crossorigin="anonymous"></script>
    <meta charset="UTF-8" />
    <meta name="description" content="SQL IN 절 자동 생성, 값 비교, Excel 데이터를 SQL INSERT로 변환하는 실무 개발자 도구. 무료, 갯수 제한 없음. Made by 임상현." />
    <meta name="keywords" content="SQL IN 절 생성기, Excel SQL 생성기, 데이터 비교, 값 차집합 도구, SQL 쿼리 자동 생성기, 개발자 도구, SHA-256 해시 생성기, RSA 암호화, JSON 비교" />
    <title>DATA 실무 도구 - SQL IN 절 생성기, 값 비교 도구, Excel → SQL INSERT 생성기, SHA-256 해시 생성기, RSA 암호화, JSON 비교</title>

    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f5f7;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }
        .container {
            margin: 40px 16px;
            max-width: 1100px;
            width: 100%;
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
            padding: 24px 24px 32px;
        }
        h1 {
            margin: 0 0 4px;
            font-size: 24px;
            font-weight: 700;
        }
        .subtitle {
            margin-bottom: 20px;
            color: #666;
            font-size: 13px;
        }
        label {
            font-size: 13px;
            font-weight: 600;
            display: block;
            margin-bottom: 6px;
        }
        textarea {
            width: 100%;
            border-radius: 10px;
            border: 1px solid #ddd;
            padding: 10px 12px;
            font-size: 13px;
            font-family: "JetBrains Mono", "Consolas", monospace;
            resize: vertical;
            min-height: 160px;
        }
        textarea:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79,70,229,0.15);
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-top: 16px;
        }
        .col {
            flex: 1 1 280px;
        }
        select, input[type="text"], input[type="number"] {
            width: 100%;
            border-radius: 8px;
            border: 1px solid #ddd;
            padding: 7px 10px;
            font-size: 13px;
            font-family: inherit;
        }
        select:focus, input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79,70,229,0.15);
        }
        .options {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-top: 8px;
            font-size: 12px;
        }
        .options label {
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 0;
        }
        .btn-row {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            border-radius: 999px;
            border: none;
            padding: 8px 18px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .btn-primary {
            background: #4f46e5;
            color: white;
        }
        .btn-secondary {
            background: #e5e7eb;
            color: #111827;
        }
        .btn-primary:active,
        .btn-secondary:active {
            transform: translateY(1px);
        }
        .result-wrapper {
            margin-top: 24px;
        }
        .small-text {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
        }
        .stats {
            margin-top: 4px;
            font-size: 12px;
            color: #555;
        }
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 11px;
            background: #eef2ff;
            color: #4338ca;
            margin-left: 8px;
        }

        /* 탭 스타일 */
        .tabs {
            margin-top: 16px;
            margin-bottom: 12px;
            display: flex;
            border-bottom: 1px solid #e5e7eb;
            gap: 4px;
            flex-wrap: wrap;
        }
        .tab-button {
            border: none;
            background: transparent;
            padding: 10px 16px;
            font-size: 13px;
            cursor: pointer;
            border-radius: 999px 999px 0 0;
            color: #6b7280;
        }
        .tab-button.active {
            background: #eef2ff;
            color: #111827;
            font-weight: 600;
        }
        .tab-content {
            display: none;
            animation: fadeIn 0.2s ease-out;
        }
        .tab-content.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* SHA 결과 박스 */
        .hash-output {
            font-family: "JetBrains Mono", Consolas, monospace;
            word-break: break-all;
            min-height: 40px;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid #ddd;
            font-size: 13px;
            background: #f9fafb;
            white-space: pre;
            overflow-x: auto;
        }

        footer {
            margin-top: 32px;
            text-align: center;
            font-size: 11px;
            color: #aaa;
        }
        @media (max-width: 700px) {
            .container {
                margin-top: 20px;
                padding: 18px 16px 24px;
            }
            h1 {
                font-size: 20px;
            }
        }
    </style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-V7H9N1Q5Q0"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-V7H9N1Q5Q0');
    </script>
</head>
<body>
<div class="container">
    <h1>DATA 실무 도구</h1>
    <div class="subtitle">
        데이터 관리하는 전문가를 위한 유틸리티 사이트입니다.
        <span class="badge">Made by 임상현 (광고 및 후원 문의 인스타 : 1imsangh)</span>
    </div>

    <!-- 탭 버튼 -->
    <div class="tabs">
        <button class="tab-button active" data-tab="inTab">IN 절 생성기</button>
        <button class="tab-button" data-tab="compareTab">값 비교 도구</button>
        <button class="tab-button" data-tab="insertTab">Excel → SQL INSERT 생성기</button>
        <button class="tab-button" data-tab="shaTab">SHA-256 해시 생성기</button>
        <button class="tab-button" data-tab="rsaTab">RSA 암호화</button>
        <button class="tab-button" data-tab="jsonTab">JSON 비교</button>
    </div>

    <!-- IN 절 생성기 탭 -->
    <section id="inTab" class="tab-content active">
        <div class="subtitle" style="margin-top: 4px;">
            한 줄당 하나씩 값 붙여넣으면 자동으로 <strong>IN (...)</strong> 형식으로 만들어줍니다.
        </div>

        <label for="inputValues">입력값 (한 줄에 하나씩 / 쉼표, 공백 모두 구분자로 인식)</label>
        <textarea id="inputValues" placeholder="예시)
4041420011181A
4041494107956A
4041493011337A"></textarea>
        <div class="small-text">
            ※ 공백·중복은 자동 제거됩니다. 데이터 양 제한 없이 사용 가능합니다.
        </div>

        <div class="row" style="margin-top: 20px;">
            <div class="col">
                <label for="wrapType">문자열 감싸기</label>
                <select id="wrapType">
                    <option value="single">'단일따옴표'</option>
                    <option value="double">"쌍따옴표"</option>
                    <option value="none">감싸지 않음</option>
                </select>
            </div>
            <div class="col">
                <label for="separator">구분자</label>
                <select id="separator">
                    <option value="comma">쉼표 + 공백 (, )</option>
                    <option value="comma_no_space">쉼표만 (,)</option>
                    <option value="newline">줄바꿈</option>
                </select>
            </div>
            <div class="col">
                <label for="template">템플릿</label>
                <select id="template">
                    <option value="in_only">괄호만: ( ... )</option>
                    <option value="with_in">IN ( ... )</option>
                    <option value="none">그냥 값만</option>
                </select>
            </div>
        </div>

        <div class="row">
            <div class="col">
                <label for="prefix">앞에 붙일 문자열</label>
                <input id="prefix" type="text" placeholder="예) AND COL_NM IN " />
            </div>
            <div class="col">
                <label for="suffix">뒤에 붙일 문자열</label>
                <input id="suffix" type="text" placeholder="예) /* comment */" />
            </div>
            <div class="col">
                <label for="maxPerLine">한 줄당 최대 개수 (줄바꿈)</label>
                <input id="maxPerLine" type="number" min="0" value="0" />
                <div class="small-text">0이면 강제 줄바꿈 없음</div>
            </div>
        </div>

        <div class="options">
            <label>
                <input type="checkbox" id="dedupe" checked />
                중복 제거
            </label>
            <label>
                <input type="checkbox" id="sortAsc" />
                오름차순 정렬
            </label>
            <label>
                <input type="checkbox" id="ignoreEmpty" checked />
                빈 값 무시
            </label>
        </div>

        <div class="btn-row">
            <button class="btn-primary" id="generateBtn">IN 절 생성</button>
            <button class="btn-secondary" id="copyBtn">복사하기</button>
        </div>

        <div class="result-wrapper">
            <label for="outputValues">결과</label>
            <textarea id="outputValues" readonly placeholder="여기에 결과가 표시됩니다."></textarea>
            <div class="stats" id="statsText"></div>
        </div>
    </section>

    <!-- 값 비교 도구 탭 -->
    <section id="compareTab" class="tab-content">
        <div class="subtitle" style="margin-top: 4px;">
            두 개의 값 목록을 붙여넣고, 공통값과 차이값을 한 번에 확인해보세요.
        </div>

        <div class="row">
            <div class="col">
                <label for="inputA">A 값 목록</label>
                <textarea id="inputA" placeholder="예시)
apple
tomato
banana"></textarea>
                <div class="small-text">※ 한 줄에 하나씩, 또는 쉼표/공백으로 구분해서 넣어도 됩니다.</div>
            </div>
            <div class="col">
                <label for="inputB">B 값 목록</label>
                <textarea id="inputB" placeholder="예시)
banana
orange
melon"></textarea>
                <div class="small-text">※ 공백·빈 줄은 자동으로 무시됩니다.</div>
            </div>
        </div>

        <div class="row" style="margin-top: 20px;">
            <div class="col">
                <label for="delimiter">구분 방식</label>
                <select id="delimiter">
                    <option value="auto">자동 (줄바꿈 + 쉼표 + 공백)</option>
                    <option value="newline">줄바꿈 기준</option>
                    <option value="comma">쉼표 기준</option>
                    <option value="space">공백 기준</option>
                </select>
                <div class="small-text">자동 모드는 줄바꿈/쉼표/공백을 모두 구분자로 사용합니다.</div>
            </div>
            <div class="col">
                <label>옵션</label>
                <div class="options">
                    <label>
                        <input type="checkbox" id="dedupeCompare" checked />
                        중복 제거
                    </label>
                    <label>
                        <input type="checkbox" id="sortAscCompare" checked />
                        오름차순 정렬
                    </label>
                    <label>
                        <input type="checkbox" id="trimSpaceCompare" checked />
                        앞뒤 공백 제거
                    </label>
                    <label>
                        <input type="checkbox" id="caseSensitiveCompare" />
                        대소문자 구분
                    </label>
                </div>
            </div>
        </div>

        <div class="btn-row">
            <button class="btn-primary" id="compareBtn">값 비교하기</button>
            <button class="btn-secondary" id="swapBtn">A ↔ B 교환</button>
        </div>

        <div class="result-wrapper">
            <div class="row">
                <div class="col">
                    <label for="commonValues">공통 값 (A ∩ B)</label>
                    <textarea id="commonValues" readonly></textarea>
                    <div class="stats" id="commonStats"></div>
                </div>
                <div class="col">
                    <label for="onlyAValues">A에만 있는 값 (A - B)</label>
                    <textarea id="onlyAValues" readonly></textarea>
                    <div class="stats" id="onlyAStats"></div>
                </div>
            </div>
            <div class="row">
                <div class="col">
                    <label for="onlyBValues">B에만 있는 값 (B - A)</label>
                    <textarea id="onlyBValues" readonly></textarea>
                    <div class="stats" id="onlyBStats"></div>
                </div>
                <div class="col">
                    <label for="allValues">전체 유니크 값 (A ∪ B)</label>
                    <textarea id="allValues" readonly></textarea>
                    <div class="stats" id="allStats"></div>
                </div>
            </div>
        </div>
    </section>

    <!-- Excel → SQL INSERT 생성기 탭 -->
    <section id="insertTab" class="tab-content">
        <div class="subtitle" style="margin-top: 4px;">
            엑셀에서 복사한 데이터를 붙여넣고, SQL INSERT 문으로 한 번에 생성하세요.
        </div>

        <div class="row">
            <div class="col">
                <label for="tableName">테이블명</label>
                <input id="tableName" type="text" placeholder="예) TB_USER, TB_ORDER 등" />
            </div>
            <div class="col">
                <label for="insertMode">INSERT 모드</label>
                <select id="insertMode">
                    <option value="multi">한 문장에 여러 VALUES (기본)</option>
                    <option value="single">행마다 INSERT 한 줄씩</option>
                </select>
            </div>
            <div class="col">
                <label for="rowDelimiter">행 구분</label>
                <select id="rowDelimiter">
                    <option value="newline">줄바꿈 기준 (엑셀에서 그대로 복붙)</option>
                </select>
            </div>
        </div>

        <div class="row">
            <div class="col">
                <label for="columns">컬럼 목록</label>
                <textarea id="columns" placeholder="예시)
id
name
age"></textarea>
                <div class="small-text">
                    줄바꿈 또는 쉼표로 컬럼명 입력 가능. (id,name,age 또는 줄마다 하나씩)
                </div>
            </div>
            <div class="col">
                <label for="excelData">Excel 데이터 붙여넣기</label>
                <textarea id="excelData" placeholder="엑셀에서 행/열 선택 후 그대로 붙여넣기
예)
1[TAB]홍길동[TAB]30
2[TAB]김철수[TAB]25"></textarea>
                <div class="small-text">
                    각 행은 줄바꿈으로, 각 열은 탭(엑셀 복사 기본) 또는 쉼표로 구분됩니다.
                </div>
            </div>
        </div>

        <div class="options">
            <label>
                <input type="checkbox" id="includeColumns" checked />
                INSERT 문에 컬럼명 포함
            </label>
            <label>
                <input type="checkbox" id="detectNumber" checked />
                숫자는 따옴표 없이 사용
            </label>
            <label>
                <input type="checkbox" id="emptyToNull" checked />
                빈 값은 NULL 처리
            </label>
            <label>
                <input type="checkbox" id="trimCell" checked />
                셀 앞뒤 공백 제거
            </label>
            <label>
                <input type="checkbox" id="semicolonEnd" checked />
                문장 끝에 세미콜론(;) 추가
            </label>
        </div>

        <div class="btn-row">
            <button class="btn-primary" id="generateInsertBtn">INSERT 문 생성</button>
            <button class="btn-secondary" id="copyInsertBtn">복사하기</button>
        </div>

        <div class="result-wrapper">
            <label for="insertResult">결과 INSERT 문</label>
            <textarea id="insertResult" readonly placeholder="INSERT 문이 여기에 표시됩니다."></textarea>
            <div class="stats" id="insertStats"></div>
        </div>
    </section>

    <!-- SHA-256 해시 생성기 탭 (추가) -->
    <section id="shaTab" class="tab-content">
        <div class="subtitle" style="margin-top: 4px;">
            텍스트를 SHA-256 알고리즘으로 해시(단방향 암호화)해주는 도구입니다.
            여러 줄 입력 시 <strong>줄마다 해시값만</strong> 출력됩니다.
        </div>

        <label for="shaInputText">입력 텍스트</label>
        <textarea id="shaInputText" placeholder="여기에 해시할 텍스트를 입력하세요.
예)
password123
user@example.com
임의의 문자열 등"></textarea>
        <div class="small-text">
            · 입력값은 <strong>절대 서버로 전송되지 않고, 브라우저 안에서만 처리</strong>됩니다.<br/>
            · SHA-256은 <strong>복호화가 불가능한 단방향 해시</strong>입니다.
        </div>

        <div class="btn-row">
            <button class="btn-primary" id="shaHashBtn">SHA-256 해시 생성</button>
            <button class="btn-secondary" id="shaCopyHashBtn">해시 복사</button>
            <button class="btn-secondary" id="shaClearBtn">초기화</button>
        </div>

        <div class="result-wrapper">
            <label>결과 해시값 (HEX)</label>
            <div id="shaHashOutput" class="hash-output"></div>
            <div class="small-text" id="shaHashInfo"></div>
        </div>
    </section>
    <section id="rsaTab" class="tab-content">
        <div class="subtitle" style="margin-top: 0;">
            RSA 공개키로 암호화 / 개인키로 복호화 (브라우저에서만 처리)
            <span class="badge">WebCrypto</span>
        </div>

        <div class="row" style="margin-top: 10px;">
            <div class="col">
                <label for="rsaKeySize">키 길이</label>
                <select id="rsaKeySize">
                    <option value="2048" selected>2048 (권장)</option>
                    <option value="3072">3072</option>
                    <option value="4096">4096</option>
                </select>
                <div class="small-text">키가 클수록 안전하지만 생성/연산이 느려질 수 있어요.</div>
            </div>
            <div class="col">
                <label for="rsaHashAlg">OAEP 해시</label>
                <select id="rsaHashAlg">
                    <option value="SHA-256" selected>SHA-256</option>
                    <option value="SHA-384">SHA-384</option>
                    <option value="SHA-512">SHA-512</option>
                </select>
                <div class="small-text">RSA-OAEP 패딩에 사용되는 해시 알고리즘입니다.</div>
            </div>
        </div>

        <div class="btn-row" style="margin-top: 12px;">
            <button class="btn-primary" id="rsaGenKeyBtn">RSA 키 생성</button>
            <button class="btn-secondary" id="rsaCopyPubBtn">공개키 복사</button>
            <button class="btn-secondary" id="rsaCopyPrivBtn">개인키 복사</button>
            <button class="btn-secondary" id="rsaClearKeyBtn">키 초기화</button>
        </div>

        <div class="row">
            <div class="col">
                <label for="rsaPublicKeyPem">공개키 (PEM)</label>
                <textarea id="rsaPublicKeyPem" placeholder="RSA 키 생성 후 여기에 표시됩니다." readonly></textarea>
            </div>
            <div class="col">
                <label for="rsaPrivateKeyPem">개인키 (PEM)</label>
                <textarea id="rsaPrivateKeyPem" placeholder="RSA 키 생성 후 여기에 표시됩니다." readonly></textarea>
                <div class="small-text">※ 개인키는 민감정보입니다. 공유/노출에 주의하세요.</div>
            </div>
        </div>

        <div class="row">
            <div class="col">
                <label for="rsaPlainText">평문(암호화할 텍스트)</label>
                <textarea id="rsaPlainText" placeholder="여기에 암호화할 텍스트를 입력하세요."></textarea>
                <div class="small-text">
                    ※ RSA는 긴 텍스트를 직접 암호화하기에 적합하지 않습니다(제한 있음). 긴 데이터는 보통 AES(대칭키)+RSA(키 암호화) 조합을 사용합니다.
                </div>
            </div>
            <div class="col">
                <label for="rsaCipherText">암호문(Base64)</label>
                <textarea id="rsaCipherText" placeholder="암호화 결과(Base64)가 여기에 표시됩니다."></textarea>
            </div>
        </div>

        <div class="btn-row">
            <button class="btn-primary" id="rsaEncryptBtn">공개키로 암호화</button>
            <button class="btn-primary" id="rsaDecryptBtn">개인키로 복호화</button>
            <button class="btn-secondary" id="rsaCopyCipherBtn">암호문 복사</button>
            <button class="btn-secondary" id="rsaClearMsgBtn">메시지 초기화</button>
        </div>

        <div class="result-wrapper">
            <label>복호화 결과(평문)</label>
            <div id="rsaDecryptedOut" class="hash-output"></div>
            <div class="small-text" id="rsaInfo"></div>
        </div>
    </section>
    <section id="jsonTab" class="tab-content">
        <div class="subtitle" style="margin-top: 4px;">
            JSON 두 개를 붙여넣고 차이점을 비교합니다. (브라우저에서만 처리)
        </div>

        <div class="row">
            <div class="col">
                <label for="jsonA">JSON A</label>
                <textarea id="jsonA" placeholder='예) {"a":1,"b":{"c":2}}'></textarea>
                <div class="small-text">※ JSON 문자열 그대로 붙여넣기</div>
            </div>
            <div class="col">
                <label for="jsonB">JSON B</label>
                <textarea id="jsonB" placeholder='예) {"a":1,"b":{"c":3}}'></textarea>
                <div class="small-text">※ JSON 문자열 그대로 붙여넣기</div>
            </div>
        </div>

        <div class="options" style="margin-top: 12px;">
            <label><input type="checkbox" id="jsonSortKeys" checked /> 키 정렬(안정적 비교)</label>
            <label><input type="checkbox" id="jsonIgnoreArrayOrder" /> 배열 순서 무시(값 set 비교)</label>
            <label><input type="checkbox" id="jsonTrimString" checked /> 문자열 앞뒤 공백 trim</label>
        </div>

        <div class="btn-row">
            <button class="btn-primary" id="jsonCompareBtn">JSON 비교</button>
            <button class="btn-secondary" id="jsonFormatBtn">A/B 포맷(정렬+들여쓰기)</button>
            <button class="btn-secondary" id="jsonSwapBtn">A ↔ B 교환</button>
            <button class="btn-secondary" id="jsonCopyDiffBtn">Diff 복사</button>
        </div>

        <div class="result-wrapper">
            <label>결과 요약</label>
            <div id="jsonSummary" class="hash-output"></div>
            <div class="small-text" id="jsonStats"></div>
        </div>

        <div class="result-wrapper">
            <label>Diff (경로 기준)</label>
            <textarea id="jsonDiffOut" readonly placeholder="차이점이 여기에 표시됩니다."></textarea>
            <div class="small-text">형식: [경로] A값 → B값</div>
        </div>
    </section>

    <footer>
        © 2025 Made by 임상현 (Sanghyun Im)
    </footer>
</div>

<script>
    // 탭 전환
    document.querySelectorAll(".tab-button").forEach(btn => {
        btn.addEventListener("click", () => {
            const target = btn.getAttribute("data-tab");

            document.querySelectorAll(".tab-button").forEach(b => b.classList.remove("active"));
            document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));

            btn.classList.add("active");
            document.getElementById(target).classList.add("active");
        });
    });

    // --- IN 절 생성기 로직 ---
    function parseInputIn(raw) {
        const tokens = raw
            .split(/[\n,\s]+/g)
            .map(v => v.trim())
            .filter(v => v.length > 0);
        return tokens;
    }

    function formatValues(values, options) {
        let arr = [...values];

        if (options.ignoreEmpty) {
            arr = arr.filter(v => v && v.trim().length > 0);
        }

        if (options.dedupe) {
            arr = Array.from(new Set(arr));
        }

        if (options.sortAsc) {
            arr.sort();
        }

        if (options.wrapType !== "none") {
            const quote = options.wrapType === "single" ? "'" : '"';
            arr = arr.map(v => quote + v.replace(new RegExp(quote, "g"), quote + quote) + quote);
        }

        let joined = "";
        if (options.maxPerLine && options.maxPerLine > 0) {
            const chunks = [];
            for (let i = 0; i < arr.length; i += options.maxPerLine) {
                chunks.push(arr.slice(i, i + options.maxPerLine));
            }
            const sep = options.separator === "newline"
                ? ",\n  "
                : (options.separator === "comma_no_space" ? "," : ", ");
            joined = chunks
                .map(c => c.join(sep))
                .join(",\n  ");
        } else {
            if (options.separator === "newline") {
                joined = arr.join(",\n");
            } else if (options.separator === "comma_no_space") {
                joined = arr.join(",");
            } else {
                joined = arr.join(", ");
            }
        }

        if (options.template === "in_only") {
            joined = "(" + joined + ")";
        } else if (options.template === "with_in") {
            joined = "IN (" + joined + ")";
        }

        joined = (options.prefix || "") + joined + (options.suffix || "");

        return {
            text: joined,
            count: arr.length
        };
    }

    document.getElementById("generateBtn").addEventListener("click", () => {
        const raw = document.getElementById("inputValues").value || "";
        const values = parseInputIn(raw);

        const options = {
            wrapType: document.getElementById("wrapType").value,
            separator: document.getElementById("separator").value,
            template: document.getElementById("template").value,
            prefix: document.getElementById("prefix").value,
            suffix: document.getElementById("suffix").value,
            maxPerLine: parseInt(document.getElementById("maxPerLine").value || "0", 10),
            dedupe: document.getElementById("dedupe").checked,
            sortAsc: document.getElementById("sortAsc").checked,
            ignoreEmpty: document.getElementById("ignoreEmpty").checked
        };

        const result = formatValues(values, options);
        document.getElementById("outputValues").value = result.text;
        document.getElementById("statsText").textContent =
            `원본: ${values.length}개 / 최종: ${result.count}개`;
    });

    document.getElementById("copyBtn").addEventListener("click", async () => {
        const out = document.getElementById("outputValues").value;
        if (!out) {
            alert("복사할 내용이 없습니다.");
            return;
        }
        try {
            await navigator.clipboard.writeText(out);
            alert("복사되었습니다.");
        } catch (e) {
            document.getElementById("outputValues").select();
            document.execCommand("copy");
            alert("복사되었습니다. (execCommand)");
        }
    });

    // --- 값 비교 도구 로직 ---
    function splitByDelimiter(raw, mode) {
        if (!raw) return [];
        let pattern;
        switch (mode) {
            case "newline":
                pattern = /[\n]+/g;
                break;
            case "comma":
                pattern = /[,]+/g;
                break;
            case "space":
                pattern = /[\s]+/g;
                break;
            case "auto":
            default:
                pattern = /[\n,\s]+/g;
                break;
        }
        return raw.split(pattern);
    }

    function parseInputCompare(raw, options) {
        let arr = splitByDelimiter(raw, options.delimiter);

        if (options.trimSpace) {
            arr = arr.map(v => v.trim());
        }
        arr = arr.filter(v => v.length > 0);

        if (!options.caseSensitive) {
            arr = arr.map(v => v.toLowerCase());
        }
        return arr;
    }

    function unique(arr) {
        return Array.from(new Set(arr));
    }

    function compareArrays(aArr, bArr, options) {
        let a = options.dedupe ? unique(aArr) : [...aArr];
        let b = options.dedupe ? unique(bArr) : [...bArr];

        const setA = new Set(a);
        const setB = new Set(b);

        const common = [];
        const onlyA = [];
        const onlyB = [];

        for (const v of a) {
            if (setB.has(v)) {
                common.push(v);
            } else {
                onlyA.push(v);
            }
        }

        for (const v of b) {
            if (!setA.has(v)) {
                onlyB.push(v);
            }
        }

        const all = unique([...a, ...b]);

        const maybeSort = (arr) => {
            if (options.sortAsc) {
                return [...arr].sort();
            }
            return arr;
        };

        return {
            common: maybeSort(common),
            onlyA: maybeSort(onlyA),
            onlyB: maybeSort(onlyB),
            all: maybeSort(all),
            counts: {
                aCount: aArr.length,
                bCount: bArr.length,
                aUnique: a.length,
                bUnique: b.length,
                common: common.length,
                onlyA: onlyA.length,
                onlyB: onlyB.length,
                all: all.length
            }
        };
    }

    document.getElementById("compareBtn").addEventListener("click", () => {
        const rawA = document.getElementById("inputA").value || "";
        const rawB = document.getElementById("inputB").value || "";

        const options = {
            delimiter: document.getElementById("delimiter").value,
            dedupe: document.getElementById("dedupeCompare").checked,
            sortAsc: document.getElementById("sortAscCompare").checked,
            trimSpace: document.getElementById("trimSpaceCompare").checked,
            caseSensitive: document.getElementById("caseSensitiveCompare").checked
        };

        const parsedA = parseInputCompare(rawA, options);
        const parsedB = parseInputCompare(rawB, options);

        const result = compareArrays(parsedA, parsedB, options);
        const joiner = "\n";

        document.getElementById("commonValues").value = result.common.join(joiner);
        document.getElementById("onlyAValues").value = result.onlyA.join(joiner);
        document.getElementById("onlyBValues").value = result.onlyB.join(joiner);
        document.getElementById("allValues").value = result.all.join(joiner);

        document.getElementById("commonStats").textContent =
            `공통 값: ${result.counts.common}개`;
        document.getElementById("onlyAStats").textContent =
            `A에만 있는 값: ${result.counts.onlyA}개 (A 원본 ${result.counts.aCount}개 / 유니크 ${result.counts.aUnique}개)`;
        document.getElementById("onlyBStats").textContent =
            `B에만 있는 값: ${result.counts.onlyB}개 (B 원본 ${result.counts.bCount}개 / 유니크 ${result.counts.bUnique}개)`;
        document.getElementById("allStats").textContent =
            `전체 유니크 값: ${result.counts.all}개`;
    });

    document.getElementById("swapBtn").addEventListener("click", () => {
        const a = document.getElementById("inputA").value;
        const b = document.getElementById("inputB").value;
        document.getElementById("inputA").value = b;
        document.getElementById("inputB").value = a;
    });

    // --- Excel → SQL INSERT 생성기 로직 ---
    function parseColumns(raw) {
        if (!raw) return [];
        let cols = raw.includes("\n") ? raw.split(/[\n]+/g) : raw.split(/[,]+/g);
        return cols
            .map(c => c.trim())
            .filter(c => c.length > 0);
    }

    function parseExcelData(raw) {
        if (!raw) return [];
        const lines = raw.split(/\n+/g).map(l => l.trim()).filter(l => l.length > 0);
        return lines.map(line => {
            if (line.includes("\t")) return line.split("\t");
            if (line.includes(",")) return line.split(",");
            return [line];
        });
    }

    function isNumericValue(str) {
        if (str === null || str === undefined) return false;
        const s = String(str).trim();
        if (s === "") return false;
        return /^-?\d+(\.\d+)?$/.test(s);
    }

    function escapeSingleQuote(str) {
        return String(str).replace(/'/g, "''");
    }

    document.getElementById("generateInsertBtn").addEventListener("click", () => {
        const tableName = (document.getElementById("tableName").value || "").trim();
        const insertMode = document.getElementById("insertMode").value;
        const columnsRaw = document.getElementById("columns").value || "";
        const excelRaw = document.getElementById("excelData").value || "";

        const includeColumns = document.getElementById("includeColumns").checked;
        const detectNumber = document.getElementById("detectNumber").checked;
        const emptyToNull = document.getElementById("emptyToNull").checked;
        const trimCell = document.getElementById("trimCell").checked;
        const semicolonEnd = document.getElementById("semicolonEnd").checked;

        if (!tableName) {
            alert("테이블명을 입력해주세요.");
            return;
        }
        if (!excelRaw.trim()) {
            alert("Excel 데이터를 붙여넣어주세요.");
            return;
        }

        const cols = parseColumns(columnsRaw);
        const rows = parseExcelData(excelRaw);

        if (cols.length === 0) {
            const maxLen = rows.reduce((m, r) => Math.max(m, r.length), 0);
            for (let i = 1; i <= maxLen; i++) cols.push("col" + i);
        }

        const normalizedRows = rows.map(r => {
            const copy = [...r];
            while (copy.length < cols.length) copy.push("");
            if (copy.length > cols.length) copy.length = cols.length;
            return copy;
        });

        const valueStrings = normalizedRows.map(row => {
            const cells = row.map(cell => {
                let v = cell;
                if (trimCell && typeof v === "string") v = v.trim();

                if (emptyToNull && (v === "" || v === null || v === undefined)) return "NULL";
                if (detectNumber && isNumericValue(v)) return String(v).trim();

                return "'" + escapeSingleQuote(v) + "'";
            });

            return "(" + cells.join(", ") + ")";
        });

        let sql = "";
        const colPart = includeColumns ? " (" + cols.join(", ") + ")" : "";

        if (insertMode === "multi") {
            sql = "INSERT INTO " + tableName + colPart + "\nVALUES\n  " + valueStrings.join(",\n  ");
            if (semicolonEnd) sql += ";";
        } else {
            sql = valueStrings
                .map(v => "INSERT INTO " + tableName + colPart + " VALUES " + v + (semicolonEnd ? ";" : ""))
                .join("\n");
        }

        document.getElementById("insertResult").value = sql;
        document.getElementById("insertStats").textContent =
            `생성된 행 수: ${normalizedRows.length}행 / 컬럼 수: ${cols.length}개`;
    });

    document.getElementById("copyInsertBtn").addEventListener("click", async () => {
        const out = document.getElementById("insertResult").value;
        if (!out) {
            alert("복사할 내용이 없습니다.");
            return;
        }
        try {
            await navigator.clipboard.writeText(out);
            alert("복사되었습니다.");
        } catch (e) {
            document.getElementById("insertResult").select();
            document.execCommand("copy");
            alert("복사되었습니다. (execCommand)");
        }
    });

    // --- SHA-256 해시 생성기 로직 (추가) ---
    function isWebCryptoAvailable() {
        return !!(window.crypto && window.crypto.subtle && window.TextEncoder);
    }

    async function generateSHA256(text) {
        const encoder = new TextEncoder();
        const data = encoder.encode(text);
        const hashBuffer = await crypto.subtle.digest("SHA-256", data);
        return Array.from(new Uint8Array(hashBuffer))
            .map(b => b.toString(16).padStart(2, "0"))
            .join("");
    }

    const shaInputEl = document.getElementById("shaInputText");
    const shaOutputEl = document.getElementById("shaHashOutput");
    const shaInfoEl = document.getElementById("shaHashInfo");

    document.getElementById("shaHashBtn").addEventListener("click", async () => {
        if (!isWebCryptoAvailable()) {
            alert("이 브라우저에서는 WebCrypto를 지원하지 않습니다. 최신 Chrome/Edge/Safari를 사용해주세요.");
            return;
        }

        const raw = shaInputEl.value || "";
        const lines = raw
            .split(/\n+/g)
            .map(v => v.trim())
            .filter(v => v.length > 0);

        if (lines.length === 0) {
            alert("SHA-256으로 변환할 텍스트를 입력해주세요.");
            return;
        }

        shaOutputEl.textContent = "계산 중...";
        shaInfoEl.textContent = "";

        const start = performance.now();
        const results = [];

        for (const line of lines) {
            const hash = await generateSHA256(line);
            results.push(hash); // 순수 해시만 출력
        }

        const end = performance.now();

        shaOutputEl.textContent = results.join("\n");
        shaInfoEl.textContent = `총 ${lines.length}개 변환 · 처리시간: ${(end - start).toFixed(2)}ms`;
    });

    document.getElementById("shaCopyHashBtn").addEventListener("click", async () => {
        const hash = shaOutputEl.textContent || "";
        if (!hash || hash === "계산 중...") {
            alert("복사할 해시 값이 없습니다.");
            return;
        }
        try {
            await navigator.clipboard.writeText(hash);
            alert("복사되었습니다.");
        } catch {
            const temp = document.createElement("textarea");
            temp.value = hash;
            document.body.appendChild(temp);
            temp.select();
            document.execCommand("copy");
            document.body.removeChild(temp);
            alert("복사되었습니다. (execCommand)");
        }
    });

    document.getElementById("shaClearBtn").addEventListener("click", () => {
        shaInputEl.value = "";
        shaOutputEl.textContent = "";
        shaInfoEl.textContent = "";
        shaInputEl.focus();
    });

    function safeJsonParse(raw) {
        const s = (raw || "").trim();
        if (!s) throw new Error("JSON이 비어있습니다.");
        return JSON.parse(s);
    }

    function normalizeJson(value, opts) {
        // 문자열 trim 옵션
        if (opts.trimString && typeof value === "string") {
            return value.trim();
        }

        if (Array.isArray(value)) {
            const arr = value.map(v => normalizeJson(v, opts));
            if (opts.ignoreArrayOrder) {
                // 배열 순서 무시: stringify 기준 정렬(간단+안정)
                return arr
                    .map(v => ({ v, k: JSON.stringify(v) }))
                    .sort((a, b) => (a.k > b.k ? 1 : a.k < b.k ? -1 : 0))
                    .map(x => x.v);
            }
            return arr;
        }

        if (value && typeof value === "object") {
            const keys = Object.keys(value);
            if (opts.sortKeys) keys.sort();
            const out = {};
            for (const k of keys) {
                out[k] = normalizeJson(value[k], opts);
            }
            return out;
        }

        return value;
    }

    function isEqual(a, b) {
        return JSON.stringify(a) === JSON.stringify(b);
    }

    function diffJson(a, b, path = "$", diffs = []) {
        // 타입 다르면 바로 diff
        const typeA = Array.isArray(a) ? "array" : (a === null ? "null" : typeof a);
        const typeB = Array.isArray(b) ? "array" : (b === null ? "null" : typeof b);

        if (typeA !== typeB) {
            diffs.push({ path, a, b, reason: "type" });
            return diffs;
        }

        // 원시값
        if (typeA !== "object" && typeA !== "array") {
            if (a !== b) diffs.push({ path, a, b, reason: "value" });
            return diffs;
        }

        // null
        if (a === null || b === null) {
            if (a !== b) diffs.push({ path, a, b, reason: "null" });
            return diffs;
        }

        // 배열
        if (typeA === "array") {
            const lenA = a.length;
            const lenB = b.length;
            const max = Math.max(lenA, lenB);
            for (let i = 0; i < max; i++) {
                const p = `${path}[${i}]`;
                if (i >= lenA) diffs.push({ path: p, a: undefined, b: b[i], reason: "added" });
                else if (i >= lenB) diffs.push({ path: p, a: a[i], b: undefined, reason: "removed" });
                else diffJson(a[i], b[i], p, diffs);
            }
            return diffs;
        }

        // 객체
        const keys = new Set([...Object.keys(a), ...Object.keys(b)]);
        const sortedKeys = Array.from(keys).sort();
        for (const k of sortedKeys) {
            const p = `${path}.${k}`;
            if (!(k in a)) diffs.push({ path: p, a: undefined, b: b[k], reason: "added" });
            else if (!(k in b)) diffs.push({ path: p, a: a[k], b: undefined, reason: "removed" });
            else diffJson(a[k], b[k], p, diffs);
        }
        return diffs;
    }

    function pretty(v) {
        if (v === undefined) return "(없음)";
        if (typeof v === "string") return `"${v}"`;
        return JSON.stringify(v);
    }

    const jsonAEl = document.getElementById("jsonA");
    const jsonBEl = document.getElementById("jsonB");
    const jsonSummaryEl = document.getElementById("jsonSummary");
    const jsonStatsEl = document.getElementById("jsonStats");
    const jsonDiffOutEl = document.getElementById("jsonDiffOut");

    document.getElementById("jsonSwapBtn").addEventListener("click", () => {
        const a = jsonAEl.value;
        const b = jsonBEl.value;
        jsonAEl.value = b;
        jsonBEl.value = a;
    });

    document.getElementById("jsonFormatBtn").addEventListener("click", () => {
        try {
            const opts = {
                sortKeys: document.getElementById("jsonSortKeys").checked,
                ignoreArrayOrder: document.getElementById("jsonIgnoreArrayOrder").checked,
                trimString: document.getElementById("jsonTrimString").checked
            };
            const a = normalizeJson(safeJsonParse(jsonAEl.value), opts);
            const b = normalizeJson(safeJsonParse(jsonBEl.value), opts);
            jsonAEl.value = JSON.stringify(a, null, 2);
            jsonBEl.value = JSON.stringify(b, null, 2);
            alert("포맷 완료!");
        } catch (e) {
            alert("포맷 실패: " + e.message);
        }
    });

    document.getElementById("jsonCompareBtn").addEventListener("click", () => {
        try {
            const opts = {
                sortKeys: document.getElementById("jsonSortKeys").checked,
                ignoreArrayOrder: document.getElementById("jsonIgnoreArrayOrder").checked,
                trimString: document.getElementById("jsonTrimString").checked
            };

            const aRaw = safeJsonParse(jsonAEl.value);
            const bRaw = safeJsonParse(jsonBEl.value);

            const a = normalizeJson(aRaw, opts);
            const b = normalizeJson(bRaw, opts);

            const same = isEqual(a, b);
            const diffs = same ? [] : diffJson(a, b);

            jsonSummaryEl.textContent = same ? "✅ 동일합니다 (Normalized 기준)" : "❌ 다릅니다 (Normalized 기준)";
            jsonStatsEl.textContent = `차이 ${diffs.length}개 · 옵션: 키정렬=${opts.sortKeys ? "ON" : "OFF"}, 배열순서무시=${opts.ignoreArrayOrder ? "ON" : "OFF"}, 문자열trim=${opts.trimString ? "ON" : "OFF"}`;

            if (same) {
                jsonDiffOutEl.value = "";
                return;
            }

            jsonDiffOutEl.value = diffs
                .map(d => `[${d.path}] ${pretty(d.a)} → ${pretty(d.b)} (${d.reason})`)
                .join("\n");
        } catch (e) {
            jsonSummaryEl.textContent = "⚠️ 비교 실패";
            jsonStatsEl.textContent = e.message || String(e);
            jsonDiffOutEl.value = "";
            alert("비교 실패: " + (e.message || e));
        }
    });

    document.getElementById("jsonCopyDiffBtn").addEventListener("click", async () => {
        const out = jsonDiffOutEl.value || "";
        if (!out) {
            alert("복사할 Diff가 없습니다.");
            return;
        }
        try {
            await navigator.clipboard.writeText(out);
            alert("복사되었습니다.");
        } catch (e) {
            jsonDiffOutEl.select();
            document.execCommand("copy");
            alert("복사되었습니다. (execCommand)");
        }
    });
    function ensureWebCrypto() {
        if (!(window.crypto && window.crypto.subtle && window.TextEncoder && window.TextDecoder)) {
            throw new Error("이 브라우저는 WebCrypto를 지원하지 않습니다. 최신 Chrome/Edge/Safari를 사용해주세요.");
        }
    }

    function arrayBufferToBase64(buf) {
        const bytes = new Uint8Array(buf);
        let binary = "";
        for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
        return btoa(binary);
    }

    function base64ToArrayBuffer(b64) {
        const binary = atob(b64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        return bytes.buffer;
    }

    function toPem(base64, label) {
        const lines = base64.match(/.{1,64}/g) || [];
        return `-----BEGIN ${label}-----\n${lines.join("\n")}\n-----END ${label}-----`;
    }

    function pemToBase64(pem) {
        return pem
            .replace(/-----BEGIN [^-]+-----/g, "")
            .replace(/-----END [^-]+-----/g, "")
            .replace(/\s+/g, "")
            .trim();
    }

    async function exportPublicKeyPem(publicKey) {
        const spki = await crypto.subtle.exportKey("spki", publicKey);
        return toPem(arrayBufferToBase64(spki), "PUBLIC KEY");
    }

    async function exportPrivateKeyPem(privateKey) {
        const pkcs8 = await crypto.subtle.exportKey("pkcs8", privateKey);
        return toPem(arrayBufferToBase64(pkcs8), "PRIVATE KEY");
    }

    async function importPublicKeyPem(pem, hashAlg) {
        const b64 = pemToBase64(pem);
        const buf = base64ToArrayBuffer(b64);
        return crypto.subtle.importKey(
            "spki",
            buf,
            { name: "RSA-OAEP", hash: hashAlg },
            true,
            ["encrypt"]
        );
    }

    async function importPrivateKeyPem(pem, hashAlg) {
        const b64 = pemToBase64(pem);
        const buf = base64ToArrayBuffer(b64);
        return crypto.subtle.importKey(
            "pkcs8",
            buf,
            { name: "RSA-OAEP", hash: hashAlg },
            true,
            ["decrypt"]
        );
    }

    function getRsaOptions() {
        return {
            modulusLength: parseInt(document.getElementById("rsaKeySize").value, 10),
            hashAlg: document.getElementById("rsaHashAlg").value
        };
    }

    const rsaPublicKeyPemEl = document.getElementById("rsaPublicKeyPem");
    const rsaPrivateKeyPemEl = document.getElementById("rsaPrivateKeyPem");
    const rsaPlainTextEl = document.getElementById("rsaPlainText");
    const rsaCipherTextEl = document.getElementById("rsaCipherText");
    const rsaDecryptedOutEl = document.getElementById("rsaDecryptedOut");
    const rsaInfoEl = document.getElementById("rsaInfo");

    let rsaKeyPair = null;

    document.getElementById("rsaGenKeyBtn").addEventListener("click", async () => {
        try {
            ensureWebCrypto();
            rsaInfoEl.textContent = "";
            rsaDecryptedOutEl.textContent = "";

            const { modulusLength, hashAlg } = getRsaOptions();

            rsaInfoEl.textContent = "키 생성 중...";
            const start = performance.now();

            rsaKeyPair = await crypto.subtle.generateKey(
                {
                    name: "RSA-OAEP",
                    modulusLength,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: hashAlg
                },
                true,
                ["encrypt", "decrypt"]
            );

            const pubPem = await exportPublicKeyPem(rsaKeyPair.publicKey);
            const privPem = await exportPrivateKeyPem(rsaKeyPair.privateKey);

            rsaPublicKeyPemEl.value = pubPem;
            rsaPrivateKeyPemEl.value = privPem;

            const end = performance.now();
            rsaInfoEl.textContent = `RSA 키 생성 완료 · ${modulusLength}bit · ${hashAlg} · ${(end - start).toFixed(2)}ms`;
        } catch (e) {
            alert("RSA 키 생성 실패: " + (e.message || e));
            rsaInfoEl.textContent = e.message || String(e);
        }
    });

    document.getElementById("rsaEncryptBtn").addEventListener("click", async () => {
        try {
            ensureWebCrypto();
            const { hashAlg } = getRsaOptions();

            const plain = (rsaPlainTextEl.value || "");
            if (!plain.trim()) {
                alert("암호화할 텍스트를 입력해주세요.");
                return;
            }

            // 공개키 우선: 화면의 PEM이 있으면 import, 없으면 생성된 keyPair 사용
            let publicKey = null;
            if ((rsaPublicKeyPemEl.value || "").trim()) {
                publicKey = await importPublicKeyPem(rsaPublicKeyPemEl.value, hashAlg);
            } else if (rsaKeyPair?.publicKey) {
                publicKey = rsaKeyPair.publicKey;
            } else {
                alert("공개키가 없습니다. 먼저 RSA 키를 생성하거나 공개키 PEM을 넣어주세요.");
                return;
            }

            const encoder = new TextEncoder();
            const data = encoder.encode(plain);

            // RSA-OAEP 입력 길이 제한 안내(대략)
            // 최대길이: k - 2*hLen - 2 (k: 바이트, hLen: 해시 바이트)
            const k = (parseInt(document.getElementById("rsaKeySize").value, 10) / 8);
            const hLen = hashAlg === "SHA-256" ? 32 : (hashAlg === "SHA-384" ? 48 : 64);
            const maxLen = k - 2 * hLen - 2;
            if (data.length > maxLen) {
                alert(`텍스트가 너무 깁니다. (현재 ${data.length}bytes, 최대 약 ${maxLen}bytes)\n긴 데이터는 AES+RSA(하이브리드) 방식을 추천해요.`);
                return;
            }

            const cipherBuf = await crypto.subtle.encrypt({ name: "RSA-OAEP" }, publicKey, data);
            const cipherB64 = arrayBufferToBase64(cipherBuf);

            rsaCipherTextEl.value = cipherB64;
            rsaInfoEl.textContent = `암호화 완료 · 입력 ${data.length}bytes`;
        } catch (e) {
            alert("암호화 실패: " + (e.message || e));
            rsaInfoEl.textContent = e.message || String(e);
        }
    });

    document.getElementById("rsaDecryptBtn").addEventListener("click", async () => {
        try {
            ensureWebCrypto();
            const { hashAlg } = getRsaOptions();

            const cipherB64 = (rsaCipherTextEl.value || "").trim();
            if (!cipherB64) {
                alert("복호화할 암호문(Base64)을 입력해주세요.");
                return;
            }

            let privateKey = null;
            if ((rsaPrivateKeyPemEl.value || "").trim()) {
                privateKey = await importPrivateKeyPem(rsaPrivateKeyPemEl.value, hashAlg);
            } else if (rsaKeyPair?.privateKey) {
                privateKey = rsaKeyPair.privateKey;
            } else {
                alert("개인키가 없습니다. 먼저 RSA 키를 생성하거나 개인키 PEM을 넣어주세요.");
                return;
            }

            const cipherBuf = base64ToArrayBuffer(cipherB64);
            const plainBuf = await crypto.subtle.decrypt({ name: "RSA-OAEP" }, privateKey, cipherBuf);

            const decoder = new TextDecoder();
            const plain = decoder.decode(plainBuf);

            rsaDecryptedOutEl.textContent = plain;
            rsaInfoEl.textContent = `복호화 완료 · 출력 ${plainBuf.byteLength}bytes`;
        } catch (e) {
            alert("복호화 실패: " + (e.message || e));
            rsaInfoEl.textContent = e.message || String(e);
            rsaDecryptedOutEl.textContent = "";
        }
    });

    async function copyTextFromEl(el, emptyMsg) {
        const txt = (el.value !== undefined ? el.value : el.textContent) || "";
        if (!txt.trim()) {
            alert(emptyMsg);
            return;
        }
        try {
            await navigator.clipboard.writeText(txt);
            alert("복사되었습니다.");
        } catch {
            if (el.select) {
                el.select();
                document.execCommand("copy");
                alert("복사되었습니다. (execCommand)");
            } else {
                const temp = document.createElement("textarea");
                temp.value = txt;
                document.body.appendChild(temp);
                temp.select();
                document.execCommand("copy");
                document.body.removeChild(temp);
                alert("복사되었습니다. (execCommand)");
            }
        }
    }

    document.getElementById("rsaCopyPubBtn").addEventListener("click", () =>
        copyTextFromEl(rsaPublicKeyPemEl, "복사할 공개키가 없습니다.")
    );
    document.getElementById("rsaCopyPrivBtn").addEventListener("click", () =>
        copyTextFromEl(rsaPrivateKeyPemEl, "복사할 개인키가 없습니다.")
    );
    document.getElementById("rsaCopyCipherBtn").addEventListener("click", () =>
        copyTextFromEl(rsaCipherTextEl, "복사할 암호문이 없습니다.")
    );

    document.getElementById("rsaClearKeyBtn").addEventListener("click", () => {
        rsaKeyPair = null;
        rsaPublicKeyPemEl.value = "";
        rsaPrivateKeyPemEl.value = "";
        rsaInfoEl.textContent = "";
        alert("키가 초기화되었습니다.");
    });

    document.getElementById("rsaClearMsgBtn").addEventListener("click", () => {
        rsaPlainTextEl.value = "";
        rsaCipherTextEl.value = "";
        rsaDecryptedOutEl.textContent = "";
        rsaInfoEl.textContent = "";
    });
    console.log("SQL 실무 도구 — Made by Sanghyun Im (임상현)");
</script>
</body>
</html>
